{
  "@metadata<desc>": "Template metadata",
  "metadata": {
    "author": "name",
    "version": "1.0",
    "created": "yyyy/mm/dd",
    "modified": "yyyy/mm/dd",
    "sdk_version": "major.minor.patch",
    "notes": ""
  },
  "@settings<desc>": "General template settings",
  "settings": {
    "@retain_pdfua<type>": "bool",
    "retain_pdfua": true,
    "@page_tag<type>": "string",
    "page_tag": "NonStruct",
    "@substructure_form_XObject<type>": "bool",
    "substructure_form_XObject": true
  },
  "@template<desc>": "Template configuration",
  "template": {
    "@pagemap<type>": "unknown",
    "@pagemap<desc>": "The pagemap node includes overall thresholds for pagemap recognition.",
    "pagemap": [
      {
        "statement": "$if",
        "@query": {},
        "@preflight_columns<desc>": "Preflight colums druring preflight method. Set to 0 if this information is not required.",
        "preflight_columns": 1,
        "@preflight_column_width_distance<desc>": "Columns width detection precision.",
        "preflight_column_width_distance": 20,
        "@preflight_column_alignment_distance<desc>": "Columns alignment detection precision.",
        "preflight_column_alignment_distance": 4,
        "@preflight_artifact_font_size_min<desc>": "Minimum font size for artifact",
        "preflight_artifact_font_size_min": 32,
        "@preflight_artifact_w1<desc>": "Horizontal alignment weight.",
        "preflight_artifact_w1": 1,
        "@preflight_artifact_w2<desc>": "Vertical alignment weight.",
        "preflight_artifact_w2": 1,
        "@preflight_artifact_w3<desc>": "Element width weight.",
        "preflight_artifact_w3": 1,
        "@preflight_artifact_w4<desc>": "Element height(for images) or font size(for text) weight.",
        "preflight_artifact_w4": 1,
        "@preflight_artifact_w5<desc>": "Page numbers weight.",
        "preflight_artifact_w5": 1,
        "@preflight_artifact_distance<desc>": "Maximum distance<0,1> when elements can be an artifact/header/footer.",
        "@preflight_artifact_distance<use>": "Detection of headers/footers and other artifacts in Preflight process.",
        "preflight_artifact_distance": 0.7,
        "@preflight_artifact_cluster_points<desc>": "Minimal number of points in preflight_artifact_distance radian.",
        "@preflight_artifact_cluster_points<use>": "Detection of headers/footers and other artifacts in Preflight process. Higher value causes that only offen repeated headers are detected.",
        "preflight_artifact_cluster_points": 2,
        "@concurrent_threads<desc>": "The number of concurrent threads. If zero, the number of concurrent threads supported by the implementation is used. If it's set to 1, no parallel algorithms are used.",
        "concurrent_threads": 0,
        "@text_only<desc>": "Process only texts in pagemap.",
        "text_only": 0,
        "@rotation_detect<desc>": "Detect and correct page rotation for reading.",
        "rotation_detect": 1,
        "@background_color_red<desc>": "Page background color - red.",
        "background_color_red": 255,
        "@background_color_green<desc>": "Page background color - green.",
        "background_color_green": 255,
        "@background_color_blue<desc>": "Page background color - blue.",
        "background_color_blue": 255,
        "@background_color_diff<desc>": "Page background color max color component difference.",
        "background_color_diff": 2,
        "@bbox_expansion<desc>": "Bounding box expansion - half of kTrTextHeight.",
        "bbox_expansion": 4,
        "@angle_deviation<desc>": "Maximum angle deviation for horizontal and vertical elements.",
        "angle_deviation": 0.015707963267949,
        "@header_ratio<desc>": "Maximum percentage of a header height. Possible values from interval [0,1].",
        "header_ratio": 0.15,
        "@footer_ratio<desc>": "Maximum percentage of a footer height. Possible values from interval [0,1].",
        "footer_ratio": 0.15,
        "@artifact_w1<desc>": "Artifact page border distance weight.",
        "artifact_w1": 1,
        "@artifact_w2<desc>": "Artifact image area weight.",
        "artifact_w2": 1,
        "@artifact_border_distance_max<desc>": "Maximum distance of artifact to page border.",
        "artifact_border_distance_max": 2,
        "@artifact_font_size<desc>": "All texts with font size bigger then this is artifact.",
        "artifact_font_size": 40,
        "@artifact_similarity<desc>": "Minimum similarity value when object or element is an artifact normalized to interval [0,1].",
        "artifact_similarity": 0.7,
        "@object_intersection<desc>": "Expansion for page objects intersection.",
        "object_intersection": 0.1,
        "@object_isolated<desc>": "Maximum isolated object heigh and width. It's used for joining isolated objects.",
        "object_isolated": 16,
        "@path_object_max<desc>": "Maximum number of subsequence path objects that are still paths.",
        "path_object_max": 2000,
        "@path_object_min<desc>": "Minimum number of subsequence path objects that are still paths.",
        "path_object_min": 100,
        "@isolated_text_ratio<desc>": "Maximum isolated text width ratio. Is multiplied with the font size.",
        "isolated_text_ratio": 10,
        "@isolated_text<desc>": "Maximum isolated text width.",
        "isolated_text": 80,
        "@isolated_element_ratio<desc>": "Maximum isolated element width/height ratio. Is multiplied with the font size.",
        "isolated_element_ratio": 6,
        "@initial_element_expansion<desc>": "Initial element bounding box expansion when searching children. Size in points. If its zero, a half of default page font size is used.",
        "initial_element_expansion": 0,
        "@element_isolated_w1<desc>": "Element paragraph weight.",
        "element_isolated_w1": 1,
        "@element_isolated_w2<desc>": "Element width weight.",
        "element_isolated_w2": 1,
        "@element_isolated_caption<desc>": "If set to 1 and element contains caption(table, image, chart, note) do not mark it as isolated element.",
        "element_isolated_caption": 1,
        "@element_isolated_width_min<desc>": "Minimal value of bbox width for isolated element. If zero, element_isolated_width_min_ratio is used. Size in points.",
        "element_isolated_width_min": 0,
        "@element_isolated_width_min_ratio<desc>": "Minimal value of bbox width for isolated element multiply with average page font size.",
        "element_isolated_width_min_ratio": 4,
        "@element_isolated_width_max<desc>": "Maximal value of bbox width for isolated element. If zero, element_isolated_width_max_ratio is used. Size in points.",
        "element_isolated_width_max": 0,
        "@element_isolated_width_max_ratio<desc>": "Maximal value of bbox width for isolated element multiply with average page font size.",
        "element_isolated_width_max_ratio": 10,
        "@element_isolated_similarity<desc>": "Minimum similarity value when element is isolated normalized to interval [0,1].",
        "element_isolated_similarity": 0.7,
        "@element_isolated_image_w1<desc>": "Image vs page area weight.",
        "element_isolated_image_w1": 1,
        "@element_isolated_image_w2<desc>": "Elements isolated similarity weight.",
        "element_isolated_image_w2": 1,
        "@element_isolated_image_w3<desc>": "Images area vs join image area weight.",
        "element_isolated_image_w3": 1,
        "@element_isolated_image_similarity<desc>": "Minimum similarity value when isolated elements can be added to an image.",
        "@element_isolated_image_similarity<use>": "Isolated elements process. Use higher value to join isolated elements to nearest images.",
        "element_isolated_image_similarity": 0.7,
        "@element_line_w1<desc>": "Line width weight.",
        "element_line_w1": 1,
        "@element_line_width_max<desc>": "Maximal value of line width. If zero, element_line_width_max_ratio is used. Size in points.",
        "element_line_width_max": 8,
        "@element_line_width_max_ratio<desc>": "Maximal value of line width multiply with average page font size.",
        "element_line_width_max_ratio": 1,
        "@element_line_similarity<desc>": "Minimum similarity value when element is recognized as line normalized to interval [0,1].",
        "@element_line_similarity<use>": "Multiple methods.",
        "element_line_similarity": 0.6,
        "@element_alignment_ratio<desc>": "Ration between baseline and bounding box alignments. Bounding box alignment precision is multiplied with element_alignment_ratio.",
        "element_alignment_ratio": 0.5,
        "@rect_image_similarity<desc>": "Minimum similarity value when rectangle is image normalized to interval [0,1].",
        "rect_image_similarity": 0.7,
        "@image_background_text<desc>": "Text bounding box expansion.",
        "@image_background_text<use>": "Image detection. Images that have same size as texts(text beackground) are moved to artifacts.",
        "image_background_text": 1,
        "@image_overlap_distance<desc>": "Maximum distance value when graphic page objects can be joined. Distance in points.",
        "@image_overlap_distance<use>": "Image detection. Lower value leaves possible labels isolated.",
        "image_overlap_distance": 1,
        "@image_join_distance<desc>": "Maximum distance value when graphic page objects can be joined. Distance in points.",
        "@image_join_distance<use>": "Image detection. Lower value leaves small isolated images.",
        "image_join_distance": 8,
        "@char_clip_ratio<desc>": "Minimal ratio of the clipping area of the character comparing to it's original size.",
        "char_clip_ratio": 0.5,
        "@word_space_width_ratio<desc>": "Default char space width ratio (percentage) based on the font size.",
        "@word_space_width_ratio<use>": "Words detection. TODO: change to clustering.",
        "word_space_width_ratio": 0.6,
        "@word_space_width_min_ratio<desc>": "Minimal acceptable space width ratio.",
        "@word_space_width_min_ratio<use>": "Words detection. TODO: change to clustering.",
        "word_space_width_min_ratio": 0.1,
        "@word_space_type<desc>": "The space's advance width detection type. If 0, font space width is calculated as average of all characters widths. If -1, maximum width is used. If -2, space character width is used. If there is a number greater then 0, font size(em) multiplied by this number is used.",
        "@word_space_type<use>": "The space's advance width detection. This info is used later to detect normal word spacing for the selected font.",
        "word_space_type": 0,
        "@word_space_distance_max<desc>": "Maximum distance between chunks. If zero, word_space_distance_max_ratio is used. Size in points.",
        "@word_space_distance_max<use>": "Text lines detection. Each space wider then this value splits the line into separate lines.",
        "word_space_distance_max": 0,
        "@word_space_distance_max_ratio<desc>": "Maximum distance between chunks. The value is multiplied by simple word spacing between words.",
        "@word_space_distance_max_ratio<use>": "Text lines detection. Each space wider then this value splits the line into separate lines.",
        "word_space_distance_max_ratio": 10,
        "@word_space_update<desc>": "Maximum distance of word spacing. Size in points.",
        "@word_space_update<use>": "Word spacing detection. Updates maximum space for normal word spacing for each font on the page. Higher value allows variable word spacing in simple paragraph.",
        "word_space_update": 0.1,
        "@word_distance<desc>": "Maximum distance value in word spacing detection. If zero, word_distance_ratio is used. Size in points.",
        "@word_distance<use>": "Text lines detection. Higher value allows creating justify paragraphs with not strictly same word spacings.",
        "word_distance": 0,
        "@word_distance_ratio<desc>": "Maximum distance value in word spacing detection. The value is multiplied by word font size.",
        "@word_distance_ratio<use>": "Text lines detection. Higher value allows creating justify paragraphs with not strictly same word spacings.",
        "word_distance_ratio": 0.1,
        "@word_space_splitter_ratio<desc>": "Minimum space before splitter. The value is multiplied by most used font size.",
        "@word_space_splitter_ratio<use>": "Words splitters detection. Use smaller value when columns are close to each other.",
        "word_space_splitter_ratio": 2,
        "@word_splitter_distance<desc>": "Maximum threshold value for word splitters detections. Real distance in points.",
        "@word_splitter_distance<use>": "Words splitters detection. ",
        "word_splitter_distance": 4,
        "@text_line_baseline_ratio<desc>": "Maximum baseline shift. Value multiplies minimal font. Baseline shift moves individual characters up or down in relation to other text on the same line.",
        "@text_line_baseline_ratio<use>": "Baseline detection. The baseline is the line upon which most letters ”sit” and below which descenders extend. Use higher value to smooth baseline shift.",
        "text_line_baseline_ratio": 0.1,
        "@text_line_underline_distance<desc>": "Distance of the underline line and text baseline. Size in points.",
        "@text_line_underline_distance<use>": "Underline text detection.",
        "text_line_underline_distance": 2.6,
        "@text_line_underline_char_distance_ratio<desc>": "Distance of the underline line start/end point and character bounding box. The value is multiplied by line font size. Size in points.",
        "@text_line_underline_char_distance_ratio<use>": "Underline text detection.",
        "text_line_underline_char_distance_ratio": 0.1,
        "@text_line_subscript_space_ratio<desc>": "Subscript space multiplied with word space.",
        "text_line_subscript_space_ratio": 0.5,
        "@text_line_subscript_font_ratio<desc>": "Mamimum subscript font size multiplied with line font size.",
        "text_line_subscript_font_ratio": 1,
        "@text_line_subscript_len<desc>": "Maximum number of characters in subscript.",
        "text_line_subscript_len": 6,
        "@text_line_join_font_size_distance<desc>": "Distance of two fonts in points, when two lines with different fonts can be join.",
        "text_line_join_font_size_distance": 0,
        "@text_line_distance_max<desc>": "Maximum distance between lines. If zero, text_line_distance_max_ratio is used. Size in points.",
        "@text_line_distance_max<use>": "Paragraphs detection. Each space wider then this value splits the text into lines.",
        "text_line_distance_max": 0,
        "@text_line_distance_max_ratio<desc>": "Maximum distance between lines. The value is multiplied by line font size.",
        "@text_line_distance_max_ratio<use>": "Paragraphs detection. Each space wider then this value splits the text into lines.",
        "text_line_distance_max_ratio": 3.6,
        "@text_line_join_distance<desc>": "Maximum threshold value in line spacing detection for specific font size. The higher value allows creating paragraph with variable line spacings. The value is multiplied by font size.",
        "@text_line_join_distance<use>": "Paragraphs detection. The higher value allows creating paragraph with variable line spacings. If zero, the minimum font size is used.",
        "text_line_join_distance": 2,
        "@text_chunk_distance_max<desc>": "Maximum distance between chunks. If zero, text_chunk_distance_max_ratio is used. Size in points.",
        "@text_chunk_distance_max<use>": "Text chunks detection. Each space wider then this value splits the line into chunks.",
        "text_chunk_distance_max": 0,
        "@text_chunk_distance_max_ratio<desc>": "Maximum distance between chunks. The value is multiplied by simple word spacing between words.",
        "@text_chunk_distance_max_ratio<use>": "Text chunks detection. Each space wider then this value splits the line into chunks.",
        "text_chunk_distance_max_ratio": 6,
        "@text_chunk_distance<desc>": "Maximum distance value when text chunks are vertically aligned. If zero, text_chunk_distance_ratio is used. Size in points.",
        "@text_chunk_distance<use>": "Paragraph detection. Higher value causes identification of tables with not stricly aligned columns.",
        "text_chunk_distance": 0,
        "@text_chunk_distance_ratio<desc>": "Maximum distance value when text chunks are vertically aligned. The value is multiplied by page font width.",
        "@text_chunk_distance_ratio<use>": "Paragraph detection. Higher value causes identification of tables with not stricly aligned columns.",
        "text_chunk_distance_ratio": 0.42,
        "@text_chunk_simple_distance<desc>": "Maximum distance value when text chunks create simple line. Normalized to interval [0,1].",
        "@text_chunk_simple_distance<use>": "Paragraph detection. Lower value.",
        "text_chunk_simple_distance": 0.4,
        "@text_chunk_word_distance<desc>": "Maximum distance value when single line text has to be split to words. Normalized to interval [0,1].",
        "text_chunk_word_distance": 0.1,
        "@text_height<desc>": "Minimal text height on the page.",
        "text_height": 8,
        "@text_simple_similarity<desc>": "Minimum similarity value when text lines create a simple paragraph normalized to interval [0,1].",
        "@text_simple_similarity<use>": "Paragraph detection. Higher value causes more solid paragraphs.",
        "text_simple_similarity": 0.96,
        "@text_justify_similarity<desc>": "Minimum similarity value when text lines create a justify paragraph normalized to interval [0,1].",
        "@text_justify_similarity<use>": "Paragraph detection. Higher value causes more solid paragraphs.",
        "text_justify_similarity": 0.96,
        "@text_table_similarity<desc>": "Minimum similarity value when text lines create a table normalized to interval [0,1].",
        "@text_table_similarity<use>": "Paragraph detection. Lower value splits lines with larger spaces into chunks to be able to detect tables.",
        "text_table_similarity": 0.65,
        "@text_paragraph_similarity<desc>": "Minimum similarity value when text is paragraph normalized to interval [0,1].",
        "text_paragraph_similarity": 0.7,
        "@text_split_distance<desc>": "Dissimilarity boundary value when text lines creates a paragraph.",
        "text_split_distance": 0.2,
        "@text_heading_h1<desc>": "Minimal font size for H1.",
        "text_heading_h1": 0,
        "@text_heading_h2<desc>": "Minimal font size for H2.",
        "text_heading_h2": 0,
        "@text_heading_h3<desc>": "Minimal font size for H3.",
        "text_heading_h3": 0,
        "@text_column_similarity<desc>": "Minimum similarity value that text creates a column normalized to interval [0,1].",
        "text_column_similarity": 0.7,
        "@label_alignment_h<desc>": "Maximum deviation of horizontal label alignment.",
        "label_alignment_h": 2,
        "@label_distance_ratio<desc>": "Distance of the label and text. Is multiplied with the page most used font size.",
        "label_distance_ratio": 10,
        "@label_baseline_ration<desc>": "Multiplies minimal font. Maximum deviation of horizontal label aligned to text.",
        "label_baseline_ration": 0.14,
        "@label_image_w1<desc>": "Labels alignment weight. Accepted only if labels overlap.",
        "label_image_w1": 1,
        "@label_image_w2<desc>": "Labels and sibling distance weight.",
        "label_image_w2": 1,
        "@label_image_w3<desc>": "Siblings font size difference weight. Accepted only if it's not equal.",
        "label_image_w3": 1,
        "@label_image_w4<desc>": "Labels width difference weight.",
        "label_image_w4": 0.25,
        "@label_image_w5<desc>": "Labels height difference weight.",
        "label_image_w5": 0.25,
        "@label_image_w6<desc>": "Label and sibling height weight.",
        "label_image_w6": 1,
        "@label_image_w7<desc>": "Label width weight.",
        "label_image_w7": 1,
        "@label_image_w8<desc>": "Labels type weight. If set to 1, accept only same type labels.",
        "label_image_w8": 0,
        "@label_image_w9<desc>": "Labels graphic state weight. If set to 1, labels have to have same graphics state.",
        "label_image_w9": 0,
        "@label_image_w10<desc>": "Siblings text state weight. If set to 1, siblings have to have same text state.",
        "label_image_w10": 0,
        "@label_image_width_min<desc>": "Minimal value of bbox width for label object. If zero, label_image_width_min_ratio is used. Size in points.",
        "label_image_width_min": 0,
        "@label_image_width_min_ratio<desc>": "Minimal value of bbox width for label objec multiply with average page font size.",
        "label_image_width_min_ratio": 1,
        "@label_image_width_max<desc>": "Maximal value of bbox width for label object. If zero, label_image_width_max_ratio is used. Size in points.",
        "label_image_width_max": 0,
        "@label_image_width_max_ratio<desc>": "Maximal value of bbox width for label object multiply with average page font size.",
        "label_image_width_max_ratio": 6,
        "@label_image_distance<desc>": "Minimum distance value when graphic page object is label. Distance in points.",
        "@label_image_distance<use>": "Image label detection. Higher value allows more flexibility in labels detection.",
        "label_image_distance": 8,
        "@label_word_w1<desc>": "Labels alignment weight.",
        "label_word_w1": 1,
        "@label_word_w2<desc>": "Labels and sibling distance weight.",
        "label_word_w2": 1,
        "@label_word_distance<desc>": "Maximum distance value when a word is a label. Distance in points.",
        "@label_word_distance<use>": "Word label detection. Higher value allows more flexibility in labels detection.",
        "label_word_distance": 0,
        "@label_word_distance_ratio<desc>": "Maximum distance value when a word is a label. The value is multiplied by avarage page font width.",
        "@label_word_distance_ratio<use>": "Word label detection. Higher value allows more flexibility in labels detection.",
        "label_word_distance_ratio": 1,
        "@label_sibling_dist_ratio<desc>": "Minimum distance of left lebel sibling. Ratio is multiplied with right sibling distance.",
        "label_sibling_dist_ratio": 1.2,
        "@toc_word_w1<desc>": "Tocs words alignment weight.",
        "toc_word_w1": 1,
        "@toc_word_distance<desc>": "Minimum distance value when word is a label. Distance in points.",
        "@toc_word_distance<use>": "TOC detection. Higher value allows more flexibility in TOC detection.",
        "toc_word_distance": 0.6,
        "@graphic_table_alignment_distance<desc>": "Maximum alignment distance value when elements can create a table. Distance in points.",
        "graphic_table_alignment_distance": 0.8,
        "@graphic_table_split_w1<desc>": "Table texts paragraph weight.",
        "graphic_table_split_w1": 1,
        "@graphic_table_split_w2<desc>": "Table texts horizontal alignment weight.",
        "graphic_table_split_w2": 1,
        "@graphic_table_split_w3<desc>": "Columns width weight.",
        "graphic_table_split_w3": 1,
        "@graphic_table_split_w4<desc>": "Number of columns weight.",
        "graphic_table_split_w4": 0.5,
        "@graphic_table_split_w5<desc>": "Number of rows weight.",
        "graphic_table_split_w5": 0.5,
        "@graphic_table_split_w6<desc>": "Page area weight.",
        "graphic_table_split_w6": 1,
        "@graphic_table_split_col_max<desc>": "Maximal number of columns when table can be split.",
        "graphic_table_split_col_max": 5,
        "@graphic_table_split_row_max<desc>": "Maximal number of rows when table can be split.",
        "graphic_table_split_row_max": 5,
        "@graphic_table_split_similarity<desc>": "Minimum similarity value when graphic table has to be split.",
        "@graphic_table_split_similarity<use>": "Graphic table detection. Page layout sometimes creates a table. Higher value preserves this layout as table (html), otherwise it's split to elements. It's important for tagging, because it requires strictly defined tables.",
        "graphic_table_split_similarity": 0.7,
        "@graphic_table_split_layout_similarity<desc>": "Minimum similarity value when graphic table has to be split.",
        "@graphic_table_split_layout_similarity<use>": "Graphic table detection. Page layout sometimes creates a table. Higher value preserves this layout as table (html), otherwise it's split to containers. It's important for tagging, because it requires strictly defined tables.",
        "graphic_table_split_layout_similarity": 0.7,
        "@graphic_table_chart_similarity<desc>": "Minimum similarity value when graphic table is a char.",
        "@graphic_table_chart_similarity<use>": "Graphic table detection. Use lower value to recognize charts(images) instead of tables.",
        "graphic_table_chart_similarity": 0.3,
        "@graphic_table_image_w1<desc>": "Images area weight. If -1, number of images is used.",
        "graphic_table_image_w1": -1,
        "@graphic_table_image_w2<desc>": "Images  weight. If -1, number of images is used.",
        "graphic_table_image_w2": -1,
        "@graphic_table_image_w3<desc>": "Chart similarity weight. If -1, number of paths is used.",
        "graphic_table_image_w3": -1,
        "@graphic_table_image_w4<desc>": "Texts vertical alignment weight.",
        "graphic_table_image_w4": 1,
        "@graphic_table_image_w5<desc>": "Table size weight.",
        "graphic_table_image_w5": 1,
        "@graphic_table_image_similarity<desc>": "Minimum similarity value when graphic table has an image.",
        "@graphic_table_image_similarity<use>": "Graphic table detection. Use lower value to recognize charts(images) instead of tables.",
        "graphic_table_image_similarity": 0.7,
        "@sect_table_row_alignment_type<desc>": "Table row alignment type [0 - strong, 1 - average, 2 - weak].",
        "@sect_table_row_alignment_type<use>": "Table detection. Select strong for strictly aligned rows.",
        "sect_table_row_alignment_type": 1,
        "@sect_table_col_alignment_type<desc>": "Table column alignment type [0 - strong, 1 - average, 2 - weak].",
        "@sect_table_col_alignment_type<use>": "Table detection. Select strong for strictly aligned columns.",
        "sect_table_col_alignment_type": 1,
        "@sect_table_col_similarity_type<desc>": "Table column similarity type [0 - column alignment distance, 1 - element distance, 2 - element size, 3 - max].",
        "@sect_table_col_similarity_type<use>": "Table detection. Table columns similarity calculation. Different weights calculation for table elements.",
        "sect_table_col_similarity_type": 0,
        "@sect_table_col_distance<desc>": "Maximum deviation value for detection nearest distancies for table columns. Real distance in points.",
        "@sect_table_col_distance<use>": "Table detection. Table columns are detected from smallest element distancies. Higher value causes more presize distancies detection.",
        "sect_table_col_distance": 0.8,
        "@sect_table_col_similarity<desc>": "Minimum similarity value when elements create table column.",
        "@sect_table_col_similarity<use>": "Table detection. Use lower values for tables that contains paragraps, select higher values for typical tables with numbers.",
        "sect_table_col_similarity": 0.36,
        "@sect_table_alignment_type<desc>": "Table column alignment type [0 - strong, 1 - average, 2 - weak]. Select strong for strictly aligned table elements.",
        "@sect_table_alignment_type<use>": "Table detection. Use strong for strictly aligned tables.",
        "sect_table_alignment_type": 2,
        "@sect_table_alignment_distance<desc>": "Maximum threshold value for detection section tables. ",
        "@sect_table_alignment_distance<use>": "Table detection. Higher value tends to recognize tables. Lower values tends to paragraph detection.",
        "sect_table_alignment_distance": 0.4,
        "@sect_table_text_col_w1<desc>": "Text column paragraph weight.",
        "sect_table_text_col_w1": 1,
        "@sect_table_text_col_w2<desc>": "Text column width weight.",
        "sect_table_text_col_w2": 1,
        "@sect_table_text_col_width_min<desc>": "Minimal value of bbox width for text in table column. If zero, sect_table_text_col_width_min_ratio is used. Size in points.",
        "sect_table_text_col_width_min": 0,
        "@sect_table_text_col_width_min_ratio<desc>": "Minimal value of bbox width for text in table column multiply with average page font size.",
        "sect_table_text_col_width_min_ratio": 1,
        "@sect_table_text_col_width_max<desc>": "Maximal value of bbox width for text in table column. If zero, sect_table_text_col_width_max_ratio is used. Size in points.",
        "sect_table_text_col_width_max": 0,
        "@sect_table_text_col_width_max_ratio<desc>": "Maximal value of bbox width for text in table column multiply with average page font size.",
        "sect_table_text_col_width_max_ratio": 8,
        "@sect_table_image_col_w1<desc>": "Image column weight.",
        "sect_table_image_col_w1": 1,
        "@sect_table_image_col_gs<desc>": "If set to 1, image column has to have same graphics state.",
        "sect_table_image_col_gs": 1,
        "@sect_table_image_col_width_min<desc>": "Minimal value of bbox width for image in table column. If zero, sect_table_image_col_width_min_ratio is used. Size in points.",
        "sect_table_image_col_width_min": 0,
        "@sect_table_image_col_width_min_ratio<desc>": "Minimal value of bbox width for image in table column multiply with average page font size.",
        "sect_table_image_col_width_min_ratio": 1,
        "@sect_table_image_col_width_max<desc>": "Maximal value of bbox width for image in table column. If zero, sect_table_image_col_width_max_ratio is used. Size in points.",
        "sect_table_image_col_width_max": 0,
        "@sect_table_image_col_width_max_ratio<desc>": "Maximal value of bbox width for image in table column multiply with average page font size.",
        "sect_table_image_col_width_max_ratio": 4,
        "@sect_table_image_col_height_min<desc>": "Minimal value of bbox height for image in table column. If zero, sect_table_image_col_height_min_ratio is used.",
        "sect_table_image_col_height_min": 0,
        "@sect_table_image_col_height_min_ratio<desc>": "Minimal value of bbox height for image in table column multiply with average page font size.",
        "sect_table_image_col_height_min_ratio": 1,
        "@sect_table_image_col_height_max<desc>": "Maximal value of bbox height for image in table column. If zero, sect_table_image_col_height_max_ratio is used.",
        "sect_table_image_col_height_max": 0,
        "@sect_table_image_col_height_max_ratio<desc>": "Maximal value of bbox height for image in table column multiply with average page font size.",
        "sect_table_image_col_height_max_ratio": 2,
        "@sect_table_column_similarity<desc>": "Minimum similarity value when elements create table column.",
        "sect_table_column_similarity": 0.5,
        "@sect_table_image_similarity_w1<desc>": "Sect table image similarity area weight.",
        "sect_table_image_similarity_w1": 1,
        "@sect_table_image_similarity_w2<desc>": "Sect table image similarity chart weight.",
        "sect_table_image_similarity_w2": 1,
        "@sect_table_image_similarity<desc>": "Minimum similarity value when section table is image normalized to interval [0,1].",
        "sect_table_image_similarity": 0.7,
        "@sect_table_paragraph_similarity<desc>": "Minimum similarity value when section table is paragraph normalized to interval [0,1].",
        "sect_table_paragraph_similarity": 0.7,
        "@table_span_col_ratio<desc>": "Intersection percentage of colspan element. Possible values from interval [0,1].",
        "table_span_col_ratio": 0.1,
        "@table_span_row_ratio<desc>": "Intersection percentage of rowspan element. Possible values from interval [0,1].",
        "table_span_row_ratio": 0.2,
        "@table_alignment_h<desc>": "Maximum deviation (in points) of horizontal table aligned elements.",
        "table_alignment_h": 1,
        "@table_alignment_v<desc>": "Maximum deviation (in points) of vertical table aligned elements.",
        "table_alignment_v": 4,
        "@table_line_intersection<desc>": "Expansion (in points) for lines intersection. It's used in table detection.",
        "table_line_intersection": 1,
        "@table_detect_form<desc>": "Recognize form fields as tables.",
        "table_detect_form": 1,
        "@table_detect_sect<desc>": "Texts (not graphic) tables detection. Possible values: 0 | 1. If 0 is set, it prevents generating tables from isolated chunk of text.",
        "table_detect_sect": 1,
        "@caption_distance<desc>": "Distance of the caption and the image/table.",
        "caption_distance": 80,
        "@caption_alignment_h<desc>": "Maximum deviation (in points) in caption and nearest element alignment.",
        "caption_alignment_h": 4,
        "@caption_alignment_v<desc>": "Maximum deviation (in points) in caption and nearest element alignment.",
        "caption_alignment_v": 4,
        "@mc_detect<desc>": "Update elements language, alternate description and actual text based on kb. Default value is set to 1 but can be turn to 0 due to optimization - when alternate description is not required.",
        "mc_detect": 1,
        "@rd_sort<desc>": "Sort elements: 0 - inbuild, 1 - original content positions, 2 - by x and y coordinates.",
        "rd_sort": 0,
        "@rd_sort_direction<desc>": "Sort elements: 0 - inbuild, 1 - prefere columns, 2 - prefere rows.",
        "rd_sort_direction": 0,
        "@rd_column_distance<desc>": "Maximum threshold value for columns detection. Real distance in points.",
        "rd_column_distance": 0.8
      }
    ],
    "@pagemap_regex<type>": "string",
    "@pagemap_regex<desc>": "The `pagemap_regex` node contains patterns for the recognition algorithm. Keys prefixed with `regex` use regular expressions; others define acceptable characters.",
    "@pagemap_regex<value>": [
      "regex_hyphen",
      "regex_bullet",
      "regex_bullet_font",
      "regex_decimal_numbering",
      "regex_roman_numbering",
      "regex_letter_numbering",
      "regex_filling",
      "regex_filling_char",
      "regex_page_number",
      "regex_first_cap",
      "regex_terminal",
      "regex_table_caption",
      "regex_image_caption",
      "regex_chart_caption",
      "regex_note_caption",
      "regex_toc_caption",
      "regex_colon",
      "regex_comma",
      "regex_letter",
      "number_chars",
      "numbering_splitter_chars"
    ],
    "pagemap_regex": [
      {
        "statement": "$if",
        "@query": {},
        "regex_hyphen": "-$",
        "regex_bullet": "^[\\u2010\\u2011\\u2212\\u005E\\u005B\\uF0A7\\uF097\\uF0BB\\u25CF\\u2022\\u25D8\\u25CB\\u25D9\\u2023\\u2043\\uF0B7\\u2212\\u204C\\u204D\\u25E6\\u29BE\\u29BF\\u21E8\\u25BA\\u25C4\\u2219\\u25A0\\uF06C\\u25A1\\u005D\\u25C6]$",
        "regex_bullet_font": "(Wingdings)|(Symbol)",
        "regex_label": "^[\\[\\(]?((M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}))|(\\d+)|([a-zA-Z]))[\\)\\]\\.]$",
        "label_chars": ".()[]",
        "regex_decimal_numbering": "^[\\[\\(]?(?:\\d{1,4}\\.){0,5}\\d{0,4}\\s?[\\)\\]\\.]?$",
        "regex_roman_numbering": "^[\\[\\(]?M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})[\\)\\]\\.]?$",
        "regex_letter_numbering": "^[\\[\\(]?[A-Za-z][\\)\\]\\.]$",
        "regex_filling": "[._]{2,}",
        "regex_filling_chars": "._",
        "regex_page_number": "(^\\d+$)|(^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$)",
        "regex_first_cap": "^[A-Z]",
        "regex_terminal": "[\\.\\!\\?]$",
        "regex_table_caption": "((^table)|(^tab\\.))",
        "regex_image_caption": "((^image)|(^img\\.)|(^figure)|(^fig\\.))",
        "regex_chart_caption": "((^chart)|(^map))",
        "regex_note_caption": "((^source\\:)|(^note\\:))",
        "regex_toc_caption": "((^content)|(^toc))",
        "regex_colon": ":$",
        "regex_comma": "[,;]$",
        "regex_letter": "^[A-Za-z]$",
        "number_chars": "-+.,%\\u20AC$\\u00A5\\u00A3",
        "numbering_splitter_chars": ".()[]"
      }
    ],
    "@form_object_process<type>": "function",
    "@form_object_process<desc>": "The test is triggered when the page form object is parsed.",
    "@form_object_process<insert>": [
      {
        "query": {
          "param": [
            "pds_form"
          ],
          "$and": []
        }
      }
    ],
    "@form_object_process": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pds_form"
          ],
          "param": [
            [
              "pds_form"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": ""
      }
    ],
    "@path_object_process<type>": "function",
    "@path_object_process<desc>": "The test is triggered when the page path object is parsed.",
    "@path_object_process<insert>": [
      {
        "query": {
          "param": [
            "pds_path"
          ],
          "$and": []
        }
      }
    ],
    "@path_object_process": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pds_path"
          ],
          "param": [
            [
              "pds_path"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@type<link>": "schema:values:type",
        "@type": ""
      }
    ],
    "@object_update<type>": "function",
    "@object_update<desc>": "The test is triggered when the page image object is tested.",
    "@object_update<insert>": [
      {
        "query": {
          "param": [
            "pds_object"
          ],
          "$and": []
        }
      }
    ],
    "@object_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pds_object"
          ],
          "param": [
            [
              "pds_object"
            ]
          ]
        }
      }
    ],
    "@image_object_process<type>": "function",
    "@image_object_process<desc>": "The test is triggered when the page image object is parsed.",
    "@image_object_process<insert>": [
      {
        "query": {
          "param": [
            "pds_image"
          ],
          "$and": []
        }
      }
    ],
    "@image_object_process": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pds_image"
          ],
          "param": [
            [
              "pds_image"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": ""
      }
    ],
    "@line_update<type>": "function",
    "@line_update<desc>": "Updates a line element after detecting horizontal and vertical lines.",
    "@line_update<insert>": [
      {
        "query": {
          "param": [
            "pde_line"
          ],
          "$and": []
        }
      }
    ],
    "@line_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_line"
          ],
          "param": [
            [
              "pde_line"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": ""
      }
    ],
    "@rect_update<type>": "function",
    "@rect_update<desc>": "Updates a rectangle element after detecting rectangles.",
    "@rect_update<insert>": [
      {
        "query": {
          "param": [
            "pde_rect"
          ],
          "$and": []
        }
      }
    ],
    "@rect_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_rect"
          ],
          "param": [
            [
              "pde_rect"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": ""
      }
    ],
    "@word_update<type>": "function",
    "@word_update<desc>": "Updates a word element after detecting words.",
    "@word_update<insert>": [
      {
        "query": {
          "param": [
            "pde_word"
          ],
          "$and": []
        }
      }
    ],
    "@word_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_word"
          ],
          "param": [
            [
              "pde_word"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@type<link>": "schema:values:type",
        "@type": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": "",
        "@heading<link>": "schema:values:heading",
        "@heading": "normal",
        "@word_flag<link>": "schema:values:word_flag",
        "@word_flag": ""
      }
    ],
    "@word_spacing<type>": "function",
    "@word_spacing<desc>": "Detects the spacing between two words.",
    "@word_spacing<insert>": [
      {
        "query": {
          "param": [
            "pde_word",
            "pde_word"
          ],
          "$and": []
        }
      }
    ],
    "@word_spacing": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_word",
            "pde_word"
          ],
          "param": [
            [
              "pde_word"
            ],
            [
              "pde_word"
            ]
          ]
        },
        "@width<desc>": "Word spacing beween two words in points.",
        "@width<type>": "float",
        "@width": 40,
        "@ratio<desc>": "Word spacing ratio between two words multiplied by the points.",
        "@ratio<type>": "float",
        "@ratio": 1.5
      }
    ],
    "@text_line_add_word<type>": "function",
    "@text_line_add_word<desc>": "The test is triggered when forming text lines from words.",
    "@text_line_add_word<rule>": "The FIRST parameter, `pde_text_line`, starts from the right side and the SECOND parameter, `pde_word`, is added from the left side, with the DIRECTION moving from right to left.",
    "@text_line_add_word<insert>": [
      {
        "query": {
          "param": [
            "pde_text_line",
            "pde_word"
          ],
          "$and": []
        }
      }
    ],
    "@text_line_add_word": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text_line",
            "pde_word"
          ],
          "param": [
            [
              "pde_text_line"
            ],
            [
              "pde_word"
            ]
          ]
        },
        "@join<desc>": "If `join` is set to 'true', the word is inserted into the current text line; if set to 'false', the word is not added.",
        "@join<type>": "bool",
        "@join<value>": [
          "true",
          "false"
        ],
        "@join": true
      }
    ],
    "@text_line_update<type>": "function",
    "@text_line_update<desc>": "Updates a text line element after detecting text lines.",
    "@text_line_update<insert>": [
      {
        "query": {
          "param": [
            "pde_text_line"
          ],
          "$and": []
        }
      }
    ],
    "@text_line_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text_line"
          ],
          "param": [
            [
              "pde_text_line"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": "",
        "@heading<link>": "schema:values:heading",
        "@heading": "normal",
        "@text_line_flag<desc>": "Sets the line regex flags:\n- **hyphen**: Hyphenated line.\n- **new_line**: Line contains a new line.\n- **indent**: Line has indentation.\n- **terminal**: Line ends with a terminal character.\n- **drop_cap**: The first character on the line is a drop cap.\n- **filling**: Line contains only filling text.\n- **justified**: Line has excessive word spacing and is likely justified.",
        "@text_line_flag<type>": "string",
        "@text_line_flag<value>": [
          "",
          "hyphen",
          "new_line",
          "indent",
          "terminal",
          "drop_cap",
          "filling",
          "uppercase"
        ],
        "@text_line_flag": ""
      }
    ],
    "@text_line_split_filling<type>": "function",
    "@text_line_split_filling<desc>": "Splits a text line based on filling.",
    "@text_line_split_filling<insert>": [
      {
        "query": {
          "param": [
            "pde_text_line"
          ],
          "$and": []
        }
      }
    ],
    "@text_line_split_filling": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text_line"
          ],
          "param": [
            [
              "pde_text_line"
            ]
          ]
        },
        "@split<desc>": "If false, ignnore such text line when splitting by filling.",
        "@split<type>": "bool",
        "@split<value>": [
          "true",
          "false"
        ],
        "@split": true
      }
    ],
    "@text_line_neighbours<type>": "function",
    "@text_line_neighbours<desc>": "Test if two neighbours text lines can form a paragraph.",
    "@text_line_neighbours<rule>": "The FIRST parameter, `pde_text_line`, is above, and the SECOND parameter, `pde_text_line`, is below, with the DIRECTION moving from top to bottom.",
    "@text_line_neighbours<insert>": [
      {
        "query": {
          "param": [
            "pde_text_line",
            "pde_text_line"
          ],
          "$and": []
        }
      }
    ],
    "@text_line_neighbours": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text_line",
            "pde_text_line"
          ],
          "param": [
            [
              "pde_text_line"
            ],
            [
              "pde_text_line"
            ]
          ]
        },
        "@join<desc>": "If `join` is set to 'true', these lines can be part of the same paragraph; if set to 'false', the paragraph is split. If the node is not present, the lines are joined based on font size and other properties.",
        "@join<type>": "bool",
        "@join<value>": [
          "true",
          "false"
        ],
        "@join": true,
        "@split<desc>": "If `split` is set to 'true', the text is divided between these lines.",
        "@split<type>": "bool",
        "@split<value>": [
          "true",
          "false"
        ],
        "@split": true
      }
    ],
    "@text_update<type>": "function",
    "@text_update<desc>": "Updates the text element after detecting paragraphs.",
    "@text_update<insert>": [
      {
        "query": {
          "param": [
            "pde_text"
          ],
          "$and": []
        }
      }
    ],
    "@text_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text"
          ],
          "param": [
            [
              "pde_text"
            ]
          ]
        },
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": "",
        "@heading<link>": "schema:values:heading",
        "@heading": "normal",
        "@text_flag<desc>": "Sets word regex flag.",
        "@text_flag<type>": "string",
        "@text_flag<value>": [
          "table_caption",
          "image_caption",
          "chart_caption",
          "note_caption",
          "filling",
          "uppercase"
        ],
        "@text_flag": "",
        "@reflow<link>": "schema:values:reflow",
        "@reflow": true
      }
    ],
    "@element_create<type>": "function",
    "@element_create<desc>": "Create user-defined elements.",
    "@element_create<insert>": [
      {
        "query": {
          "$and": []
        },
        "elements": [
          {
            "type": "pde_element",
            "bbox": {
              "left": 0,
              "bottom": 0,
              "right": 0,
              "top": 0
            }
          }
        ]
      }
    ],
    "@element_create": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {},
        "@elements<desc>": "Array of pre-defined elements.",
        "@elements<type>": "array",
        "@elements": [
          {
            "@alt<link>": "schema:values:alt",
            "alt": "",
            "@flag<link>": "schema:values:flag",
            "@flag": "",
            "@type<link>": "schema:values:type",
            "type": "",
            "@bbox<link>": "schema:values:bbox",
            "bbox": "",
            "@tag<link>": "schema:values:tag",
            "@tag": "",
            "@heading<link>": "schema:values:heading",
            "@heading": "normal"
          }
        ]
      }
    ],
    "@element_update<type>": "function",
    "@element_update<desc>": "Updates an element after detecting basic elements.",
    "@element_update<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@element_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_image",
              "pde_line",
              "pde_rect",
              "pde_table"
            ]
          ]
        },
        "@alt<link>": "schema:values:alt",
        "@alt": "",
        "@flag<link>": "schema:values:flag",
        "@flag": "",
        "@label<link>": "schema:values:label",
        "@label": "",
        "@tag<link>": "schema:values:tag",
        "@tag": ""
      }
    ],
    "@table_recognize<type>": "function",
    "@table_recognize<desc>": "The test is triggered during the table recognition process for detecting columns and rows. This test can be called multiple times!",
    "@table_recognize<insert>": [
      {
        "query": {
          "param": [
            "pde_table"
          ],
          "$and": []
        }
      }
    ],
    "@table_recognize": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_table"
          ],
          "param": [
            [
              "pde_table"
            ]
          ]
        },
        "@isolated<desc>": "If `isolated` is set to `true`, isolated elements determine additional table coordinates; otherwise, the process stops when graphic table coordinates are recognized.",
        "@isolated<type>": "bool",
        "@isolated<value>": [
          "true",
          "false"
        ],
        "@isolated": true
      }
    ],
    "@caption_join<type>": "function",
    "@caption_join<desc>": "Finds the element for text that has been marked as a caption.",
    "@caption_join<insert>": [
      {
        "query": {
          "param": [
            "pde_text"
          ],
          "$and": []
        }
      }
    ],
    "@caption_join": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_text"
          ],
          "param": [
            [
              "pde_text"
            ]
          ]
        },
        "@distance<desc>": "Defines the maximum distance of the caption from the element. This value updates the default threshold for 'caption_dist'.",
        "@distance<type>": "float",
        "@distance": 80,
        "@position<desc>": "Defines the caption's location in relation to the nearest element.",
        "@position<type>": "string",
        "@position<value>": [
          "left",
          "right",
          "top",
          "bottom"
        ],
        "@position": ""
      }
    ],
    "@table_update<type>": "function",
    "@table_update<desc>": "Updates a table after the whole process od table detection is done.",
    "@table_update<insert>": [
      {
        "query": {
          "param": [
            "pde_table"
          ],
          "$and": []
        }
      }
    ],
    "@table_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_table"
          ],
          "param": [
            [
              "pde_table"
            ]
          ]
        },
        "@delete_empty<desc>": "If set to true, empty rows and columns are removed.",
        "@delete_empty<type>": "bool",
        "@delete_empty<value>": [
          "true",
          "false"
        ],
        "@delete_empty": true,
        "@split<desc>": "If set to true, all table elements are split to fit into the cells.",
        "@split<type>": "bool",
        "@split<value>": [
          "true",
          "false"
        ],
        "@split": true,
        "@span_empty<desc>": "If set to true, empty cells are merged together using a span.",
        "@span_empty<type>": "bool",
        "@span_empty<value>": [
          "true",
          "false"
        ],
        "@span_empty": true,
        "@span_empty_rows_first<desc>": "If set to true, empty rows are merged together first using span, followed by columns; otherwise, they are merged in the opposite order.",
        "@span_empty_rows_first<type>": "bool",
        "@span_empty_rows_first<value>": [
          "true",
          "false"
        ],
        "@span_empty_rows_first": false,
        "@span_row<desc>": "If set to true, rows are merged based on the maximum available row span.",
        "@span_row<type>": "bool",
        "@span_row<value>": [
          "true",
          "false"
        ],
        "@span_row": false,
        "@join<desc>": "If set to true, all text elements in a single cell are combined into one paragraph.",
        "@join<type>": "bool",
        "@join<value>": [
          "true",
          "false"
        ],
        "@join": false,
        "@header<desc>": "If set to true, table headers are detected, which is essential for table tagging.",
        "@header<type>": "bool",
        "@header<value>": [
          "true",
          "false"
        ],
        "@header": true
      }
    ],
    "@table_detect_header<type>": "function",
    "@table_detect_header<desc>": "Defines the rules for detecting table headers and tests whether the text is a header in a table.",
    "@table_detect_header<insert>": [
      {
        "query": {
          "param": [
            "pde_table",
            "pde_text"
          ],
          "$and": []
        }
      }
    ],
    "@table_detect_header": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_table",
            "pde_element"
          ],
          "param": [
            [
              "pde_table"
            ],
            [
              "pde_text",
              "pde_cell"
            ]
          ]
        },
        "@col<desc>": "If set to true and the query is passed, the input text is designated as a column table header.",
        "@col<type>": "bool",
        "@col<value>": [
          "true",
          "false"
        ],
        "@col": false,
        "@row<desc>": "If set to true and the query is passed, the input text is designated as a row table header.",
        "@row<type>": "bool",
        "@row<value>": [
          "true",
          "false"
        ],
        "@row": false,
        "@row_num<desc>": "If a number greater than 0 is present and no headers have been detected, set the row indicated by `row_num` as the table header.",
        "@row_num<type>": "int",
        "@row_num": 0,
        "@col_num<desc>": "If a number greater than 0 is present and no headers have been detected, set the column indicated by `col_num` as the table header.",
        "@col_num<type>": "int",
        "@col_num": 0
      }
    ],
    "@table_split<type>": "function",
    "@table_split<desc>": "Updates the table after the entire table detection process is completed.",
    "@table_split<insert>": [
      {
        "query": {
          "param": [
            "pde_table",
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@table_split": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_table",
            "pde_element"
          ],
          "param": [
            [
              "pde_table"
            ],
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@row<desc>": "If set to true, the table is split by the row that contains an element from the query.",
        "@row<type>": "bool",
        "@row<default>": false,
        "@row": false
      }
    ],
    "@single_instance_detect<type>": "function",
    "@single_instance_detect<desc>": "Detects handles for elements that require a single occurrence only.",
    "@single_instance_detect<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@single_instance_detect": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@text<desc>": "If set to true, compare text buffers to identify a single instance.",
        "@text<type>": "bool",
        "@text<value>": [
          "true",
          "false"
        ],
        "@text": false,
        "@left<desc>": "If set to true, compare the left coordinate to identify a single instance.",
        "@left<type>": "bool",
        "@left<value>": [
          "true",
          "false"
        ],
        "@left": false,
        "@top<desc>": "If set to true, compare the top coordinate to identify a single instance.",
        "@top<type>": "bool",
        "@top<value>": [
          "true",
          "false"
        ],
        "@top": false,
        "@widht<desc>": "If set to true, compare the element width to identify a single instance.",
        "@widht<type>": "bool",
        "@widht<value>": [
          "true",
          "false"
        ],
        "@widht": false,
        "@height<desc>": "If set to true, compare the element height to identify a single instance.",
        "@height<type>": "bool",
        "@height<value>": [
          "true",
          "false"
        ],
        "@height": false
      }
    ],
    "@alt_update<type>": "function",
    "@alt_update<desc>": "Sets an alternate description for the element. The alternate description is established in a specific order. To skip a step, set the default value to false for that step.",
    "@alt_update<rule>": "If existing Alternate Text is not EMPTY, new text will be not apply",
    "@alt_update<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@alt_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@mc<desc>": "If set to true, the alternate description is taken from the original marked content and the Alt tag. If there is no marked content or if marked content is set to false, proceed to the next step.",
        "@mc<type>": "bool",
        "@mc<value>": [
          "true",
          "false"
        ],
        "@mc": true,
        "@children<desc>": "If true, alternate description is taken from the children of the element. Currently only PdeImage is supported. All texts from PdeTexts children inside the image are joined into the output alternate description. If there are no children node is set to false, continue to the next step.",
        "@children<type>": "bool",
        "@children<value>": [
          "true",
          "false"
        ],
        "@children": true,
        "@caption<desc>": "If set to true, the alternate description is taken from the nearest caption, if it exists.",
        "@caption<type>": "bool",
        "@caption<value>": [
          "true",
          "false"
        ],
        "@caption": true,
        "@distance<desc>": "Defines the maximum distance of the alternate description from the element. This value updates the default threshold for 'caption_dist'. To skip this step, set the value to 0.",
        "@distance<type>": "float",
        "@distance": 80,
        "@position<desc>": "Defines the position of the alternate description in relation to the element. This can be used if the distance is set to more than 0.",
        "@position<type>": "string",
        "@position<value>": [
          "left",
          "right",
          "top",
          "bottom"
        ],
        "@position": "",
        "@alt<desc>": "The alternate description is set to this value if it is present.",
        "@alt<type>": "string",
        "@alt": ""
      }
    ],
    "@actual_text_update<type>": "function",
    "@actual_text_update<desc>": "Sets the actual text for the element. The actual text is established in a specific order. To skip a step, set the default value to false for that step.",
    "@actual_text_update<rule>": "If existing Actual Text is not EMPTY, new text will be not apply",
    "@actual_text_update<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@actual_text_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@mc<desc>": "If set to true, the actual text is taken from the original marked content and the Alt tag. If there is no marked content or if marked content is set to false, proceed to the next step.",
        "@mc<type>": "bool",
        "@mc<value>": [
          "true",
          "false"
        ],
        "@mc": true,
        "@children<desc>": "If set to true, the actual text is taken from the children of the element, currently supporting only `PdeImage`. All text from `PdeText` children within the image is combined into the output description. If there are no child nodes, set it to false and proceed to the next step.",
        "@children<type>": "bool",
        "@children<value>": [
          "true",
          "false"
        ],
        "@children": true,
        "@caption<desc>": "If set to true, the actual text is taken from the nearest caption, if it exists.",
        "@caption<type>": "bool",
        "@caption<value>": [
          "true",
          "false"
        ],
        "@caption": true,
        "@distance<desc>": "Defines the maximum distance of the alternate description from the element. This value updates the default threshold for 'caption_dist'. To skip this step, set the value to 0.",
        "@distance<type>": "float",
        "@distance": 80,
        "@position<desc>": "Defines the position of the alternate description in relation to the element. This can be used if the distance is set to more than 0.",
        "@position<type>": "string",
        "@position<value>": [
          "left",
          "right",
          "top",
          "bottom"
        ],
        "@position": "",
        "@actual_text<desc>": "The actual text is set to this value if it is present.",
        "@actual_text<type>": "string",
        "@actual_text": ""
      }
    ],
    "@artifact_update<type>": "function",
    "@artifact_update<desc>": "Marks an element as an artifact.",
    "@artifact_update<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@artifact_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@artifact<desc>": "If set to false, the artifact is moved back to elements; for example, a background image can be relocated into a meaningful element.",
        "@artifact<type>": "bool",
        "@artifact<value>": [
          "true",
          "false"
        ],
        "@artifact": true
      }
    ],
    "@reading_order_detect<type>": "function",
    "@reading_order_detect<desc>": "Detect reading order options",
    "@reading_order_detect": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {},
        "@type<desc>": "Type of reading order detection.\n- tsp: Using a TSP algorithm\n- xy: Using the x-y coordinates\n-n content: Using the order defined by the page content",
        "@type<type>": "string",
        "@type<value>": [
          "tsp",
          "xy",
          "content"
        ],
        "@type": "tsp"
      }
    ],
    "@label_update<type>": "function",
    "@label_update<desc>": "Update elements marked as labels to include them as part of the list.",
    "@label_update<insert>": [
      {
        "query": {
          "param": [
            "pde_element"
          ],
          "$and": []
        }
      }
    ],
    "@label_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_element"
          ],
          "param": [
            [
              "pde_element",
              "pde_text",
              "pde_text_line",
              "pde_word",
              "pde_text_run",
              "pde_image",
              "pde_container",
              "pde_list",
              "pde_line",
              "pde_rect",
              "pde_table",
              "pde_cell",
              "pde_toc",
              "pde_header",
              "pde_footer",
              "pde_form_field",
              "pde_annot"
            ]
          ]
        },
        "@label<link>": "schema:values:label",
        "@label": ""
      }
    ],
    "@list_update<type>": "function",
    "@list_update<desc>": "Tests if a list is correct.",
    "@list_update<insert>": [
      {
        "query": {
          "param": [
            "pde_list"
          ],
          "$and": []
        }
      }
    ],
    "@list_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_list"
          ],
          "param": [
            [
              "pde_list",
              "pde_word"
            ]
          ]
        },
        "@split<desc>": "If set to true, splits the list back into individual elements. The label flag remains on each list item.",
        "@split<type>": "bool",
        "@split<value>": [
          "true",
          "false"
        ],
        "@split": false
      }
    ],
    "@tag_list<type>": "function",
    "@tag_list<desc>": "Handles the process of tagging lists.",
    "@tag_list<insert>": [
      {
        "query": {
          "param": [
            "pde_list",
            "pde_word"
          ],
          "$and": []
        }
      }
    ],
    "@tag_list": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_list",
            "pde_word"
          ],
          "param": [
            [
              "pde_list"
            ],
            [
              "pde_word"
            ]
          ]
        },
        "@numbering<desc>": "Set the list numbering attribute.",
        "@numbering<type>": "string",
        "@numbering<value>": [
          "None",
          "Unordered",
          "Disc",
          "Circle",
          "Square",
          "Ordered",
          "Decimal",
          "UpperRoman",
          "LowerRoman",
          "UpperAlpha",
          "LowerAlpha",
          "Description"
        ],
        "@numbering": "",
        "@continued<desc>": "Set the continued list attribute.",
        "@continued<type>": "bool",
        "@continued<value>": [
          "true",
          "false"
        ],
        "@continued": false
      }
    ],
    "@tag_image<type>": "function",
    "@tag_image<desc>": "Handles the process of tagging images. For repurposing and accessibility purposes, a Figure element should have either an Alt entry or an ActualText entry in its structure element dictionary. If both are absent, the default behavior is to tag the Figure with an empty alt attribute.",
    "@tag_image<insert>": [
      {
        "query": {
          "param": [
            "pde_image"
          ],
          "$and": []
        }
      }
    ],
    "@tag_image": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_image"
          ],
          "param": [
            [
              "pde_image"
            ]
          ]
        },
        "@alt<desc>": "Sets the value of the alt text if it is present.",
        "@alt<type>": "string",
        "@alt": "",
        "@actual_text<desc>": "Sets the value of the actual text if it is present.",
        "@actual_text<type>": "string",
        "@actual_text": "",
        "@artifact<desc>": "If set to true and there is no alt or actual text present, a Figure element should be tagged as an artifact. Setting this node to false allows tagging this image with empty alt/actual text, even if it is not PDF/UA compliant!",
        "@artifact<type>": "bool",
        "@artifact<value>": [
          "true",
          "false"
        ],
        "@artifact": false,
        "@children<desc>": "If set to true, all image children (texts and form fields) are properly tagged. Since PDF 2.0, a Figure tag can also contain other tags. If set to false, all children are tagged as artifacts.",
        "@children<type>": "bool",
        "@children<value>": [
          "true",
          "false"
        ],
        "@children": false
      }
    ],
    "@tag_table<type>": "function",
    "@tag_table<desc>": "Handles the process of tagging tables. For repurposing and accessibility purposes, a table should have headers. If no headers are detected, the default behavior is to leave the table without any `<th>` elements.",
    "@tag_table<insert>": [
      {
        "query": {
          "param": [
            "pde_table"
          ],
          "$and": []
        }
      }
    ],
    "@tag_table": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_table"
          ],
          "param": [
            [
              "pde_table"
            ]
          ]
        },
        "@split<desc>": "If set to true and no headers are detected, the table should be split into cells, with each cell tagged individually. Setting this node to false allows tagging the table without headers, even if it is not PDF/UA compliant!",
        "@split<type>": "bool",
        "@split<value>": [
          "true",
          "false"
        ],
        "@split": false,
        "@row<desc>": "If set to true and the table needs to be split, the table should be divided into cells using the row reading order.",
        "@row<type>": "bool",
        "@row<value>": [
          "true",
          "false"
        ],
        "@row": true,
        "@col<desc>": "If set to true and the table needs to be split, the table should be divided into cells using the column reading order.",
        "@col<type>": "bool",
        "@col<value>": [
          "true",
          "false"
        ],
        "@col": false,
        "@summary<desc>": "A table summary for use in non-visual rendering, such as speech or braille.",
        "@summary<type>": "string",
        "@summary": ""
      }
    ],
    "@tag_annot<type>": "function",
    "@tag_annot<desc>": "Handles the process of tagging annotations.",
    "@tag_annot<insert>": [
      {
        "query": {
          "param": [
            "pde_annot"
          ],
          "$and": []
        }
      }
    ],
    "@tag_annot": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pde_annot"
          ],
          "param": [
            [
              "pde_annot"
            ]
          ]
        },
        "@remove<desc>": "Removes the annotation from the page, typically used for invalid annotations.",
        "@remove<type>": "bool",
        "@remove<value>": [
          "true",
          "false"
        ],
        "@remove": false
      }
    ],
    "@tag_update<type>": "function",
    "@tag_update<desc>": "Updates the tag after it has been created..",
    "@tag_update<insert>": [
      {
        "query": {
          "param": [
            "pds_struct_elem"
          ],
          "$and": []
        }
      }
    ],
    "@tag_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pds_struct_elem"
          ],
          "param": [
            [
              "pds_struct_elem"
            ]
          ]
        }
      }
    ],
    "@annot_update<type>": "function",
    "@annot_update<desc>": "Updates the annotation tag after it has been created.",
    "@annot_update<insert>": [
      {
        "query": {
          "param": [
            "pdf_annot"
          ],
          "$and": []
        }
      }
    ],
    "@annot_update": [
      {
        "@disable": false,
        "@disable<link>": "schema:keywords:disable",
        "@statement": "$if",
        "@statement<link>": "schema:keywords:statement",
        "@query": {
          "@param<type>": "query_param",
          "@param<insert>": [
            "pdf_annot"
          ],
          "param": [
            [
              "pdf_annot"
            ]
          ]
        }
      }
    ]
  },
  "@schema": {
    "statement<desc>": "The `if` statement type of the query. According to the statement the query evaluation stops upon pass or not.",
    "statement<use>": "Can by used in all functions. The it-statement type of the query. According to the statement the query evaluation stops upon pass or not. If statment is not present, is set to default.",
    "statement<value>": [
      "$if",
      "$elif",
      "$else"
    ],
    "statement<default>": "$if",
    "statement": {
      "$if": "",
      "$if<type>": "statement",
      "$if<desc>": "Can by used in all functions. General logic of IF statement.",
      "$elif": "",
      "$elif<type>": "statement",
      "$elif<desc>": "Can by used in all functions. General logic of ELSE IF statement.",
      "$else": "",
      "$else<type>": "statement",
      "$else<desc>": "Can by used in all functions. General logic of ELSE statement."
    },
    "query<type>": "query",
    "query<desc>": "The query defines thresholds and operations for a pagemap detection.",
    "query": {
      "param<desc>": "Define the number and type of input parameters.",
      "param<type>": "query_param",
      "param": {
        "pds_object_params": "",
        "pds_object_params<desc>": "A parameter that represents PdsObject. The value starts with the character $, followed by a number (e.g., $0_width). The number represents the index of the parameter in the param array.",
        "pds_object_params<link>": "schema:pds_object_params",
        "pde_element_params": "",
        "pde_element_params<desc>": "A parameter that represents PdeElement. The value starts with the character $, followed by a number (e.g., $0_width). The number represents the index of the parameter in the param array.",
        "pde_element_params<link>": "schema:pde_element_params",
        "pds_struct_elem_params": "",
        "pds_struct_elem_params<desc>": "A parameter that represents PdsStructElem. The value starts with the character $, followed by a number (e.g., $0_width). The number represents the index of the parameter in the param array.",
        "pds_struct_elem_params<link>": "schema:pds_struct_elem_params",
        "pdf_annot_params": "",
        "pdf_annot_params<desc>": "A parameter that represents PdfAnnots. The value starts with the character $, followed by a number (e.g., $0_width). The number represents the index of the parameter in the param array.",
        "pdf_annot_params<link>": "schema:pdf_annot_params",
        "pdf_rect": "",
        "pdf_rect<link>": "schema:values:pdf_rect",
        "pdf_rgb": "",
        "pdf_rgb<link>": "schema:values:pdf_rgb",
        "int": "",
        "int<desc>": "Parameter that represents integer.",
        "int<type>": "int",
        "bool": "",
        "bool<desc>": "Parameter that represents boolean value.",
        "bool<type>": "bool",
        "float": "",
        "float<desc>": "Parameter that represents floating value.",
        "float<type>": "float",
        "string": "",
        "string<desc>": "Parameter that represents string value.",
        "string<type>": "string"
      },
      "var<desc>": "User defined variables. Use scheme:arithmetic_operators to define variables",
      "var<type>": "var",
      "var": {
        "arithmetic_operator": "",
        "arithmetic_operator<link>": "schema:arithmetic_operators",
        "0_value": "",
        "0_value<type>": "var_value",
        "0_value<value>": [
          "left",
          "bottom",
          "right",
          "top",
          "width",
          "height"
        ]
      },
      "logical_operators": "",
      "logical_operators<link>": "schema:logical_operators"
    },
    "logical_operators<desc>": "Available logical operators.",
    "logical_operators<type>": "string",
    "logical_operators<value>": [
      "$and",
      "$or",
      "$not"
    ],
    "logical_operators": {
      "$and<type>": "logical_operator",
      "$and<desc>": "Logical AND.",
      "$and<num_values>": 2,
      "$and<insert>": [],
      "$and": {
        "$and": "",
        "$or": "",
        "$not": "",
        "condition": "",
        "condition<link>": "schema:condition"
      },
      "$or<type>": "logical_operator",
      "$or<desc>": "Logical OR.",
      "$or<num_values>": 2,
      "$or<insert>": [],
      "$or": {
        "$and": "",
        "$or": "",
        "$not": "",
        "condition": "",
        "condition<link>": "schema:condition"
      },
      "$not<type>": "logical_operator",
      "$not<desc>": "Logical NOT.",
      "$not<num_values>": 1,
      "$not<insert>": [],
      "$not": {
        "$and": "",
        "$or": "",
        "$not": "",
        "condition": "",
        "condition<link>": "schema:condition"
      }
    },
    "comparison_operators<desc>": "Available comparison operators.",
    "comparison_operators<type>": "string",
    "comparison_operators<value>": [
      "$eq",
      "$ne",
      "$lt",
      "$lte",
      "$gt",
      "$gte",
      "$regex",
      "$in",
      "$nin"
    ],
    "comparison_operators": {
      "$eq": "",
      "$eq<type>": "comparison_operator",
      "$eq<desc>": "Equality comparison operator.",
      "$eq<num_values>": 1,
      "$eq<types>": [
        "int",
        "float",
        "string"
      ],
      "$ne": "",
      "$ne<type>": "comparison_operator",
      "$ne<desc>": "Nequality comparator operator.",
      "$ne<num_values>": 1,
      "$ne<types>": [
        "int",
        "float",
        "string"
      ],
      "$lt": "",
      "$lt<type>": "comparison_operator",
      "$lt<desc>": "Less than comparison operator.",
      "$lt<num_values>": 1,
      "$lt<types>": [
        "int",
        "float"
      ],
      "$lte": "",
      "$lte<type>": "comparison_operator",
      "$lte<desc>": "Less than or equals operator.",
      "$lte<num_values>": 1,
      "$lte<types>": [
        "int",
        "float"
      ],
      "$gt": "",
      "$gt<type>": "comparison_operator",
      "$gt<desc>": "Greater than operator.",
      "$gt<num_values>": 1,
      "$gt<types>": [
        "int",
        "float"
      ],
      "$gte": "",
      "$gte<type>": "comparison_operator",
      "$gte<desc>": "Greater than or equals operator.",
      "$gte<num_values>": 1,
      "$gte<types>": [
        "int",
        "float"
      ],
      "$regex": "",
      "$regex<type>": "comparison_operator",
      "$regex<desc>": "Regular expression predicate.",
      "$regex<num_values>": 1,
      "$regex<types>": [
        "string"
      ],
      "$in": "",
      "$in<type>": "comparison_operator",
      "$in<desc>": "Contain value operator.",
      "$in<num_values>": 1,
      "$in<types>": [],
      "$nin": "",
      "$nin<type>": "comparison_operator",
      "$nin<desc>": "Not contain value operator.",
      "$nin<num_values>": 1,
      "$nin<types>": []
    },
    "arithmetic_operators<desc>": "Available arithmetic_operators.",
    "arithmetic_operators<type>": "string",
    "arithmetic_operators<value>": [
      "$sum",
      "$diff",
      "$abs",
      "$mul",
      "$div",
      "$min",
      "$max",
      "$mod"
    ],
    "arithmetic_operators": {
      "$sum<type>": "arithmetic_operator",
      "$sum<desc>": "Sum of two numbers.",
      "$sum<types>": [
        "int",
        "float"
      ],
      "$sum<num_values>": 0,
      "$sum": {
        "arithmetic_operator": "$sum",
        "[0]": 0,
        "[1]": 0
      },
      "$diff<type>": "arithmetic_operator",
      "$diff<desc>": "Difference of two numbers.",
      "$diff<types>": [
        "int",
        "float"
      ],
      "$diff<num_values>": 2,
      "$diff": {
        "arithmetic_operator": "$diff",
        "[0]": 0,
        "[1]": 0
      },
      "$abs<type>": "arithmetic_operator",
      "$abs<desc>": "Absolute value of a single number.",
      "$abs<types>": [
        "int",
        "float"
      ],
      "$abs<num_values>": 1,
      "$abs": {
        "arithmetic_operator": "$abs",
        "[0]": 0
      },
      "$mul<type>": "arithmetic_operator",
      "$mul<desc>": "Multiply two numbers.",
      "$mul<types>": [
        "int",
        "float"
      ],
      "$mul<num_values>": 2,
      "$mul": {
        "arithmetic_operator": "$mul",
        "[0]": 0,
        "[1]": 0
      },
      "$div<type>": "arithmetic_operator",
      "$div<desc>": "division two numbers.",
      "$div<types>": [
        "int",
        "float"
      ],
      "$div<num_values>": 2,
      "$div": {
        "arithmetic_operator": "$div",
        "[0]": 0,
        "[1]": 0
      },
      "$min<type>": "arithmetic_operator",
      "$min<desc>": "Get minimal value from any number of values.",
      "$min<types>": [
        "int",
        "float"
      ],
      "$min<num_values>": 0,
      "$min": {
        "arithmetic_operator": "$min",
        "[0]": 0,
        "[1]": 0
      },
      "$max<type>": "arithmetic_operator",
      "$max<desc>": "Get maximal value from any number of values.",
      "$max<types>": [
        "int",
        "float"
      ],
      "$max<num_values>": 0,
      "$max": {
        "arithmetic_operator": "$max",
        "[0]": 0,
        "[1]": 0
      },
      "$mod<type>": "arithmetic_operator",
      "$mod<desc>": "Get the modulus from a division of values.",
      "$mod<types>": [
        "int",
        "int"
      ],
      "$mod<num_values>": 0,
      "$mod": {
        "arithmetic_operator": "$mod",
        "[0]": 0,
        "[1]": 2
      }
    },
    "pds_object_params<desc>": "List of all pds_object types, can be used as parameter in QUERY->PARAM.",
    "pds_object_params": {
      "pds_text<desc>": "Text page object",
      "pds_text": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox<link>": "schema:values:bbox",
        "bbox": "",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "artifact": "",
        "artifact<link>": "schema:values:artifact",
        "mcid": "",
        "mcid<link>": "schema:values:mcid",
        "font_size": "",
        "font_size<link>": "schema:values:font_size",
        "font_name": "",
        "font_name<link>": "schema:values:font_name",
        "text": "",
        "text<link>": "schema:values:text"
      },
      "pds_path": "",
      "pds_path<link>": "schema:pds_object_params:pds_text",
      "pds_image": "",
      "pds_image<link>": "schema:pds_object_params:pds_text",
      "pds_shading": "",
      "pds_shading<link>": "schema:pds_object_params:pds_text",
      "pds_form": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox<link>": "schema:values:bbox",
        "bbox": "",
        "children_num": "",
        "children_num<link>": "schema:values:children_num",
        "artifact": "",
        "artifact<link>": "schema:values:artifact",
        "mcid": "",
        "mcid<link>": "schema:values:mcid"
      },
      "pds_object": {
        "type": "",
        "type<desc>": "Type of PdsObject.",
        "type<type>": "string",
        "type<value>": [
          "pds_object",
          "pds_text",
          "pds_path",
          "pds_image",
          "pds_shading",
          "pds_form"
        ],
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox<link>": "schema:values:bbox",
        "bbox": "",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "children_num": "",
        "children_num<link>": "schema:values:children_num",
        "artifact": "",
        "artifact<link>": "schema:values:artifact",
        "mcid": "",
        "mcid<link>": "schema:values:mcid",
        "font_size": "",
        "font_size<link>": "schema:values:font_size",
        "font_name": "",
        "font_name<link>": "schema:values:font_name",
        "text": "",
        "text<link>": "schema:values:text"
      }
    },
    "pds_struct_elem_params<desc>": "List of all pds_tag types, can be used as parameter in QUERY->PARAM.",
    "pds_struct_elem_params": {
      "pds_struct_elem": {
        "type": "",
        "type<desc>": "Type of PdsTag.",
        "type<type>": "string",
        "type<value>": [
          "pds_struct_elem"
        ],
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox<link>": "schema:values:bbox",
        "bbox": "",
        "tag_type": "",
        "tag_type<link>": "schema:values:tag_type",
        "parent_tag_type": "",
        "parent_tag_type<link>": "schema:values:parent_tag_type",
        "id": "",
        "id<link>": "schema:values:id",
        "title": "",
        "title<link>": "schema:values:title",
        "lang": "",
        "lang<link>": "schema:values:lang",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text",
        "text": "",
        "text<link>": "schema:values:text",
        "expansion": "",
        "espansion<link>": "schema:values:expansion",
        "children_num": "",
        "children_num<link>": "schema:values:children_num",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "font_size": "",
        "font_size<link>": "schema:values:font_size",
        "font_name": "",
        "font_name<link>": "schema:values:font_name",
        "has_content": "",
        "has_content<link>": "schema:values:has_content"
      }
    },
    "pdf_annot_params<desc>": "List of all pdf_annot types, can be used as parameter in QUERY->PARAM.",
    "pdf_annot_params": {
      "pdf_annot": {
        "type": "",
        "type<desc>": "Type of PdfAnnot.",
        "type<type>": "string",
        "type<value>": [
          "pdf_annot"
        ],
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox<link>": "schema:values:bbox",
        "bbox": "",
        "annot_type": "",
        "annot_type<link>": "schema:values:annot_type",
        "font_size": "",
        "font_size<link>": "schema:values:font_size",
        "font_name": "",
        "font_name<link>": "schema:values:font_name",
        "contents": "",
        "contents<link>": "schema:values:contents",
        "annot_flag": "",
        "annot_flag<link>": "schema:values:annot_flag"
      }
    },
    "pde_element_params<desc>": "List of all pde_element types, can be used as parameter in QUERY->PARAM.",
    "pde_element_params": {
      "pde_text": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "label": "",
        "label<link>": "schema:values:label",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text",
        "font_size": "",
        "font_size<link>": "schema:values:font_size",
        "font_name": "",
        "font_name<link>": "schema:values:font_name",
        "text": "",
        "text<link>": "schema:values:text",
        "angle": "",
        "angle<link>": "schema:values:angle",
        "heading": "",
        "heading<link>": "schema:values:heading"
      },
      "pde_text_line": "",
      "pde_text_line<link>": "schema:pde_element_params:pde_text",
      "pde_word": "",
      "pde_word<link>": "schema:pde_element_params:pde_text",
      "pde_text_run": "",
      "pde_text_run<link>": "schema:pde_element_params:pde_text",
      "pde_image": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "label": "",
        "label<link>": "schema:values:label",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text",
        "children_num": "",
        "children_num<link>": "schema:values:children_num"
      },
      "pde_container": "",
      "pde_container<link>": "schema:pde_element_params:pde_image",
      "pde_list": "",
      "pde_list<link>": "schema:pde_element_params:pde_image",
      "pde_rect": "",
      "pde_rect<link>": "schema:pde_element_params:pde_image",
      "pde_cell": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "cell_column": "",
        "cell_column<link>": "schema:values:cell_column",
        "cell_row": "",
        "cell_row<link>": "schema:values:cell_row"
      },
      "pde_toc": "",
      "pde_toc<link>": "schema:pde_element_params:pde_image",
      "pde_header": "",
      "pde_header<link>": "schema:pde_element_params:pde_image",
      "pde_footer": "",
      "pde_footer<link>": "schema:pde_element_params:pde_image",
      "pde_line": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "label": "",
        "label<link>": "schema:values:label",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text"
      },
      "pde_form_field": "",
      "pde_form_field<link>": "schema:pde_element_params:pde_line",
      "pde_annot": "",
      "pde_annot<link>": "schema:pde_element_params:pde_line",
      "pde_table": {
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "label": "",
        "label<link>": "schema:values:label",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text",
        "row_num": "",
        "row_num<link>": "schema:values:row_num",
        "col_num": "",
        "col_num<link>": "schema:values:col_num",
        "header": "",
        "header<link>": "schema:values:header",
        "table_type": "",
        "table_type<link>": "schema:values:table_type",
        "isolated_num": "",
        "isolated_num<desc>": "Number of isolated elements in the table.",
        "isolated_num<type>": "int"
      },
      "pde_element": {
        "type": "",
        "type<desc>": "Type of PdeElement.",
        "type<type>": "string",
        "type<value>": [
          "pde_element",
          "pde_text",
          "pde_text_line",
          "pde_word",
          "pde_text_run",
          "pde_image",
          "pde_container",
          "pde_list",
          "pde_line",
          "pde_rect",
          "pde_table",
          "pde_cell",
          "pde_toc",
          "pde_header",
          "pde_footer",
          "pde_form_field",
          "pde_annot"
        ],
        "width": "",
        "width<link>": "schema:values:width",
        "height": "",
        "height<link>": "schema:values:height",
        "left": "",
        "left<link>": "schema:values:left",
        "right": "",
        "right<link>": "schema:values:right",
        "top": "",
        "top<link>": "schema:values:top",
        "bottom": "",
        "bottom<link>": "schema:values:bottom",
        "bbox": "",
        "bbox<link>": "schema:values:bbox",
        "label": "",
        "label<link>": "schema:values:label",
        "fill_color": "",
        "fill_color<link>": "schema:values:fill_color",
        "stroke_color": "",
        "stroke_color<link>": "schema:values:stroke_color",
        "angle": "",
        "angle<link>": "schema:values:angle",
        "alt": "",
        "alt<link>": "schema:values:alt",
        "actual_text": "",
        "actual_text<link>": "schema:values:actual_text",
        "flag": "",
        "flag<link>": "schema:values:flag"
      }
    },
    "general_vars<desc>": "General variables can be used without parameters. It represents general state during the processing. It contains information about the current page and the document and can be used in any query.",
    "general_vars<type>": "string",
    "general_vars": {
      "$page_num": "",
      "$page_num<desc>": "Page number.",
      "$page_num<type>": "int",
      "$page_width": "",
      "$page_width<desc>": "Page cropbox width.",
      "$page_width<type>": "float",
      "$page_height": "",
      "$page_height<desc>": "Page cropbox height.",
      "$page_height<type>": "float",
      "$page_rotation": "",
      "$page_rotation<desc>": "Page rotation.",
      "$page_rotation<type>": "int",
      "$page_rotation<value>": [
        0,
        90,
        180,
        270
      ],
      "$doc_num_pages": "",
      "$doc_num_pages<desc>": "Document number of pages.",
      "$doc_num_pages<type>": "int",
      "$doc_lang": "",
      "$doc_lang<desc>": "Document language.",
      "$doc_lang<type>": "string",
      "$doc_title": "",
      "$doc_title<desc>": "Document title.",
      "$doc_title<type>": "string"
    },
    "values<desc>": "General values used in JSON default template.",
    "values": {
      "actual_text": "",
      "actual_text<desc>": "Actual text.",
      "actual_text<type>": "string",
      "alt": "",
      "alt<desc>": "Alternate description typically used for Figure tags.",
      "alt<type>": "string",
      "lang": "",
      "lang<desc>": "The language identifier of the document or tag.",
      "lang<type>": "string",
      "id": "",
      "id<desc>": "The unique identifier of the tag.",
      "id<type>": "string",
      "expansion": "",
      "expansion<desc>": "The expanded form of an abbreviation.",
      "expansion<type>": "string",
      "has_content": "",
      "has_content<desc>": "A value identifying whether the object or tag has associated page content.",
      "has_content<type>": "bool",
      "has_content<value>": [
        "true",
        "false"
      ],
      "tag_type": "",
      "tag_type<desc>": "Tag type defined by a string or regular expression. Use `.*` to match all tags.",
      "tag_type<type>": "string",
      "tag_type<value>": [
        "Annot",
        "Art",
        "Artifact",
        "Aside",
        "BibEntry",
        "BlockQuote",
        "Caption",
        "Code",
        "Div",
        "Document",
        "DocumentFragment",
        "Em",
        "FENote",
        "Figure",
        "Form",
        "Formula",
        "H",
        "H1",
        "H2",
        "H3",
        "H4",
        "H5",
        "H6",
        "Index",
        "L",
        "Lbl",
        "LBody",
        "LI",
        "Link",
        "NonStruct",
        "Note",
        "P",
        "Part",
        "Private",
        "Quote",
        "RB",
        "Reference",
        "RP",
        "RT",
        "Ruby",
        "Sect",
        "Span",
        "Strong",
        "Sub",
        "Table",
        "TBody",
        "TD",
        "TFoot",
        "TH",
        "THead",
        "Title",
        "TOC",
        "TOCI",
        "TR",
        "Warichu",
        "WP",
        "WT"
      ],
      "parent_tag_type": "",
      "parent_tag_type<link>": "schema:values:tag_type",
      "annot_type": "",
      "annot_type<desc>": "Annotation type defined by a string or regular expression. Use `.*` to match all annotations.",
      "annot_type<type>": "string",
      "annot_type<value>": [
        "Text",
        "Link",
        "FreeText",
        "Line",
        "Square",
        "Circle",
        "Polygon",
        "PolyLine",
        "Highlight",
        "Underline",
        "Squiggly",
        "StrikeOut",
        "Stamp",
        "Caret",
        "Ink",
        "Popup",
        "FileAttachment",
        "Sound",
        "Movie",
        "Widget",
        "Screen",
        "PrinterMark",
        "TrapNet",
        "Watermark",
        "3D",
        "Redact",
        "Projection",
        "RichMedia"
      ],
      "contents": "",
      "contents<desc>": "A string value specifying the annotation contents.",
      "contents<type>": "string",
      "annot_flag": 0,
      "annot_flag<desc>": "A comma-delimited string value specifying the annotation flags.",
      "annot_flag<type>": "string",
      "annot_flag<value>": [
        "invisible",
        "hidden",
        "print",
        "no_zoom",
        "no_rotate",
        "no_view",
        "read_only",
        "locked",
        "toggle",
        "contents"
      ],
      "title": "",
      "title<desc>": "Title.",
      "title<type>": "string",
      "angle": "",
      "angle<desc>": "Angle.",
      "angle<type>": "float",
      "bbox<desc>": "Parameter that represents the bounding box of an object, formatted as an array: `[left, bottom, right, top]`.",
      "bbox<type>": "bbox",
      "bbox": {
        "left": 0,
        "bottom": 0,
        "right": 0,
        "top": 0
      },
      "cell_column": "",
      "cell_column<desc>": "The column number of the cell in the table.",
      "cell_column<type>": "int",
      "cell_row": "",
      "cell_row<desc>": "The row number of the cell in the table.",
      "cell_row<type>": "int",
      "col_num": "",
      "col_num<desc>": "Number of columns in the table.",
      "col_num<type>": "int",
      "children_num": "",
      "children_num<desc>": "Number of associated child page objects.",
      "children_num<type>": "int",
      "artifact": "",
      "artifact<desc>": "True if object has content mark Artifact, false otherwise.",
      "artifact<type>": "bool",
      "artifact<value>": [
        "true",
        "false"
      ],
      "mcid": "",
      "mcid<desc>": "MCID content mark number is exists, -1 otherwise.",
      "mcid<type>": "int",
      "fill_color<desc>": "The fill color of an object.",
      "fill_color<type>": "rgb",
      "fill_color": {
        "red": 0,
        "green": 0,
        "blue": 0
      },
      "stroke_color<desc>": "The stroke color of an object.",
      "stroke_color<type>": "rgb",
      "stroke_color": {
        "red": 0,
        "green": 0,
        "blue": 0
      },
      "flag": "",
      "flag<desc>": "The flag value defines a specific property for an object, which is essential for further processing.",
      "flag<type>": "string",
      "flag<value>": [
        "no_join",
        "no_split",
        "artifact",
        "header",
        "footer",
        "splitter",
        "no_table",
        "table"
      ],
      "font_name": "",
      "font_name<desc>": "The name of the font used in the text object.",
      "font_name<type>": "string",
      "font_size": "",
      "font_size<desc>": "The size of the font used in the text object.",
      "font_size<type>": "float",
      "red": 0,
      "red<desc>": "The red component of an RGB color.",
      "red<type>": "int",
      "green": 0,
      "green<desc>": "The green component of an RGB color.",
      "green<type>": "int",
      "blue": 0,
      "blue<desc>": "The blue component of an RGB color.",
      "blue<type>": "int",
      "header": "",
      "header<desc>": "Marks the object as a table header.",
      "header<type>": "bool",
      "header<value>": [
        "true",
        "false"
      ],
      "heading": "",
      "heading<desc>": "Sets the text heading style.",
      "heading<type>": "string",
      "heading<value>": [
        "normal",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "h7",
        "h8",
        "note",
        "title"
      ],
      "width": "",
      "width<desc>": "The object's width dimension.",
      "width<type>": "float",
      "height": "",
      "height<desc>": "The object's height dimension.",
      "height<type>": "float",
      "label": "",
      "label<desc>": "Marks the element as a list label.",
      "label<type>": "string",
      "label<value>": [
        "",
        "label",
        "li_1",
        "li_2",
        "li_3",
        "li_4",
        "label_no"
      ],
      "left": "",
      "left<desc>": "The left coordinate of the object.",
      "left<type>": "float",
      "right": "",
      "right<desc>": "The left coordinate of the object.",
      "right<type>": "float",
      "top": "",
      "top<desc>": "The top coordinate of the object.",
      "top<type>": "float",
      "bottom": "",
      "bottom<desc>": "The bottom coordinate of the object.",
      "bottom<type>": "float",
      "pdf_rect<desc>": "Parameter that represents the bounding box of an object, formatted as an array: `[left, bottom, right, top]`.",
      "pdf_rect<type>": "rec",
      "pdf_rect": {
        "left": 0,
        "bottom": 0,
        "right": 0,
        "top": 0
      },
      "pdf_rgb<desc>": "Parameter that represents the RGB color of an object, formatted as an array: `[red, green, blue]`.",
      "pdf_rgb<type>": "rgb",
      "pdf_rgb": {
        "red": 0,
        "green": 0,
        "blue": 0
      },
      "reflow": "",
      "reflow<desc>": "Text reflow. If set to false, each line is treated as a new line.",
      "reflow<type>": "bool",
      "reflow<value>": [
        "true",
        "false"
      ],
      "row_num": "",
      "row_num<desc>": "The number of rows in the table.",
      "row_num<type>": "int",
      "table_type": "",
      "table_type<desc>": "The table type represented as a value from the `PdfTableType` enum.",
      "table_type<type>": "string",
      "table_type<value>": [
        "graphic",
        "isolated",
        "row",
        "col",
        "form"
      ],
      "tag": "",
      "tag<desc>": "The tag name to be used.",
      "tag<type>": "string",
      "text": "",
      "text<desc>": "The text to be used as a value.",
      "text<type>": "string",
      "text_flag": "",
      "text_flag<desc>": "The flag to be used for the text element, specifying a value similar to the regex flags.",
      "text_flag<type>": "string",
      "text_flag<value>": [
        "table_caption",
        "image_caption",
        "chart_caption",
        "note_caption",
        "filling",
        "uppercase"
      ],
      "text_line_flag": "",
      "text_line_flag<desc>": "The flag to be used for the text line element, specifying a value similar to the regex flags.",
      "text_line_flag<type>": "string",
      "text_line_flag<value>": [
        "hyphen",
        "new_line",
        "indent",
        "terminal",
        "drop_cap",
        "filling",
        "uppercase"
      ],
      "type": "",
      "type<desc>": "Marks the object or element with a type, aiding in the recognition of the correct element type.",
      "type<type>": "string",
      "type<value>": [
        "pds_object",
        "pds_text",
        "pds_path",
        "pds_image",
        "pds_shading",
        "pds_form",
        "pde_element",
        "pde_text",
        "pde_text_line",
        "pde_word",
        "pde_text_run",
        "pde_image",
        "pde_container",
        "pde_list",
        "pde_line",
        "pde_rect",
        "pde_table",
        "pde_cell",
        "pde_toc",
        "pde_header",
        "pde_footer",
        "pde_form_field",
        "pde_annot"
      ],
      "word_flag": "",
      "word_flag<desc>": "The flag to be used for the word element, specifying a value similar to the regex flags.",
      "word_flag<type>": "string",
      "word_flag<value>": [
        "hyphen",
        "bullet",
        "colon",
        "number",
        "subscript",
        "superscript",
        "terminal",
        "capital",
        "image",
        "decimal_num",
        "roman_num",
        "letter_num",
        "page_num",
        "filling",
        "uppercase",
        "comma",
        "no_unicode"
      ]
    },
    "suffix<desc>": "Container holding all unique suffixes used for naming in JSON default template",
    "suffix<rule>": "If element name has suffix, its taken as additional data about element before suffix and its not read by program as a child of element(his possible value).",
    "suffix": {
      "<desc>": "Description of element.",
      "<use>": "Description how to use function, object, value or anything else.",
      "<type>": "Type of element.",
      "<types>": "Array of possible element types.",
      "<value>": "Array of possible values of element.",
      "<default>": "Default value of element.",
      "<rule>": "Describes how the element setup works.",
      "<num_values>": "Number of values needs to be set.",
      "<link>": "Refer to the target element in JSON, which contain needed data.",
      "<insert>": "Value will be used as TreeItem for inserting into TreeView JSON structer"
    },
    "condition<desc>": "Conditions types used in the query",
    "condition": {
      "condition_value<desc>": "{0_width : 100}",
      "condition_value": 0,
      "comparison<desc>": "{0_width : {$lt : 100}",
      "comparison": {
        "$eq": 0
      },
      "comparison_array<desc>": "{0_width : [{$lt : 100}, {$gt : 100}, ...]}",
      "comparison_array": {
        "$gt": 0,
        "$lt": 0
      }
    },
    "keywords<desc>": "Container holding all unique keywords used in JSON default template",
    "keywords": {
      "general": "",
      "general<desc>": "Holding general data like: version, date, id, SDK version, ...",
      "template": "",
      "template<desc>": "Holding all functions.",
      "query": "",
      "query<desc>": "Can be used in all functions. Each QUERY must have child PARAM, which holding array of parameters to specified query objects.",
      "param": "",
      "param<desc>": "Child of the QUERY. Each QUERY must include a PARAM that specifies the object types used for evaluation.",
      "param<type>": "array_param",
      "statement": "$if",
      "statement<desc>": "The `if` statement should be used in function nodes. Based on the statement, the query evaluation stops upon pass or fail. If the `if` statement is not present, the condition is considered disabled.",
      "statement<type>": "string",
      "statement<value>": [
        "$if",
        "$elif",
        "$else"
      ],
      "disable": false,
      "disable<desc>": "Can by used in all main functions nodes. If value is true, node is not executed. Default value is false",
      "disable<type>": "bool",
      "disable<values>": [
        "true",
        "false"
      ],
      "purpose": "",
      "purpose<desc>": "Describes the user-defined purpose or description of the QUERY.",
      "purpose<type>": "string"
    },
    "insert<desc>": "Values to be added as the default for the node.",
    "insert": {
      "elements_add_value": "",
      "elements_add_value<insert>": {
        "type": "pde_element",
        "bbox": {
          "left": 0,
          "bottom": 0,
          "right": 0,
          "top": 0
        }
      }
    }
  }
}